<html>
  <head>
    <title>Implicit Flow Example Form</title>
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
  </head>
  <body>
    <h1>Implicit Flow Example</h1>
    <p>Paste your Video Cloud account ID into the field below and click Submit.  You should
    already have a BC_TOKEN cookie readable in whatever domain the oauth and analytics servers
    live in (your local host or brightcove.com, depending).  The scripts on this form will
    attempt to fetch an access token from Brightcove OAuth and then use it to submit a request to
    the Analytics API.  The results will appear below.</p>
    <form>
      <div>
        <label for="f_account">Account ID:</label>
        <input type="text" name="f_account" id="f_account" />
      </div>
      <input type="submit" value="Submit" />
    </form>
    <iframe id="oauth_iframe"></iframe>
    <div id="results" />
    <script type="text/javascript">
$(function () {

// URL of the implicit flow token endpoint
var token_url = 'https://oauth.brightcove.com/v3/authorization';

// Common arguments.
var default_token_args = {
    // Fixed, do not change it
    response_type: "token",
    // Replace this with the ID of your trusted=true client app registration
    client_id: '46498895-f097-4751-9a33-07480f11d868',
    // Replace this with the redirect URL of your client app registration
    redirect_uri: 'https://localhost:4000/receive_token.html'
};

// Compose the token request URL from arguments
var token_query_url = function (args) {
    return token_url + '?' + $.param(args);
};

// URL of the API call you actually want to make
var resource_url = 'https://data.brightcove.com/analytics-api/videocloud/account/:account-id/report?dimensions=video,player';

// Execute the API call with the access token
var query_analytics = function (access_token, account) {
    console.log("Querying Analytics with account " + account + " and token " + access_token);
    $('#results').text('Querying...');

    var call_url = resource_url.replace(/:account-id/, account);

    $.ajax(call_url,
           { headers: { Authorization: 'Bearer ' + access_token },
             cache: false,
             dataType: "html", // don't parse the json, just display the text for the demo
             success: function (data, textStatus, jqXHR) {
                 $('#results').text(data);
             },
             error: function (jqXHR, textStatus, errorThrown) {
                 $('#results').text('ANALYTICS FAIL: ' + textStatus + ' ' + errorThrown);
             } });
};

// These functions are called out of the iframe by the javascript in the loaded redirect
// In a real example you would do something clever to protect them against clashes
window.receive_error = function (error_code) {
    alert('ONOZ! ' + error_code);
};
window.receive_token = function (token) {
    query_analytics(token, $('#f_account').val());
};

// Compose an access token for the operation string we want on our Video Cloud account
var scope_token = function (account) {
    return account + "__vca:video-cloud/analytics/read";
};

// On form submission, fetch the OAuth2 token by setting the src property of our iframe to the
// token query URL; it will come back with a redirect to receive_token.html, whose javascript
// will read the fragment ID and call the appropriate function, receive_error or receive_token
$('form').submit(function () {
    // validate the inputs
    var account = $('#f_account').val().trim();
    if (account.length == 0) {
        alert('Account ID is required.')
        return false;
    }

    // This is for CSRF rejection; it will be returned unchanged in
    // the token response. You should always generate a new, random
    // value for each request and ensure that it comes back
    // verbatim.
    var state = Math.random().toString();
    var more_args = {
        scope: scope_token(account),
        state: state
    };
    var token_args = $.extend({}, default_token_args, more_args);
    var $frame = $('#oauth_iframe');
    // Note that this approach of attaching the state value to the
    // iframe only allows for one request at a time. You may want a
    // more robust way to tie state values to OAuth token requests.
    $frame.attr('anti_csrf_state', state);
    // Fetch the token (ask the OAuth server to bounce us to a script
    // we will load with it.)
    $frame.prop('src', token_query_url(token_args))

    // suppress default action
    return false;
});

});
    </script>
  </body>
</html>
